
# EX 3D Sudoku solver - Backtracking.
## DATE:
## AIM:
To write a Java program to solve a Sudoku puzzle by filling the empty cells.

For example:
<img width="357" height="322" alt="image" src="https://github.com/user-attachments/assets/334b8c39-d547-4743-aca0-de92e38bdd1c" />



## Algorithm
```
1. Start the program and read the 9×9 Sudoku board.
Empty cells are represented by 0.
2. Define a function isSafe(board, row, col, num) to check if placing num in position (row, col) is valid:
Check that num does not already exist in the same row.
Check that num does not already exist in the same column.
Check that num does not exist in the 3×3 subgrid containing (row, col).
Return true if all checks pass; otherwise, return false.
3. Define a recursive function solveSudoku(board, row, col):
If (row == 8 && col == 9), all cells are filled → return true (solution found).
If col == 9, move to the next row (row + 1) and set col = 0.
If the current cell is already filled (non-zero), call solveSudoku for the next column.
For an empty cell (0):
Try placing numbers 1 through 9:
If isSafe() returns true, temporarily place the number.
Recursively call solveSudoku() for the next cell.
If recursion succeeds, return true.
If not, backtrack by resetting the cell to 0.
If no number can be placed, return false.
4. In the main() method:
Input the Sudoku grid from the user.
Call solveSudoku(board, 0, 0).
If it returns true, print the solved Sudoku grid using printBoard().
Otherwise, print “No solution exists.”
5. End the program.  
``` 

## Program:
```
/*
Program to implement Reverse a String
Developed by: SARANYA S
Register Number:  212223110044
*/
```
```
import java.util.Scanner;

public class SudokuSolver {

    // Check if it's safe to place the number
    static boolean isSafe(int[][] board, int row, int col, int num) {
        // Check row and column
        for (int i = 0; i < 9; i++) {
            if (board[row][i] == num || board[i][col] == num)
                return false;
        }

        // Check 3x3 subgrid
        int startRow = row - row % 3;
        int startCol = col - col % 3;

        for (int i = 0; i < 3; i++)
            for (int j = 0; j < 3; j++)
                if (board[startRow + i][startCol + j] == num)
                    return false;

        return true;
    }

    // Recursive backtracking solver
    static boolean solveSudoku(int[][] board, int row, int col) {
        //Type your code here
        if(row==8 && col==9) return true;
        if(col==9){
            row++;
            col=0;
        }
        if(board[row][col]!=0){
           return solveSudoku(board,row,col+1); 
        }
        for(int num=1;num<=9;num++){
            if(isSafe(board,row,col,num)){
                board[row][col]=num;
                if(solveSudoku(board,row,col+1))
                return true;
                board[row][col]=0;
            }
        }
        return false;
    }

    // Utility to print the board
    static void printBoard(int[][] board) {
        for (int[] row : board) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[][] board = new int[9][9];

      //  System.out.println("Enter the Sudoku puzzle row by row (use 0 for empty cells):");

        for (int i = 0; i < 9; i++) {
            //System.out.print("Enter row " + (i + 1) + ": ");
            for (int j = 0; j < 9; j++) {
                board[i][j] = sc.nextInt();
            }
        }

      //  System.out.println("\nSolving...\n");

        if (solveSudoku(board, 0, 0)) {
            System.out.println("Solved Sudoku:");
            printBoard(board);
        } else {
            System.out.println("No solution exists.");
        }

        sc.close();
    }
}

```

## Output:
<img width="721" height="635" alt="image" src="https://github.com/user-attachments/assets/41aced99-dbf1-47ea-a17d-0709d3e02419" />



## Result:
The program successfully implemented and the expected output is verified.
